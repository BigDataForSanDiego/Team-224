#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define MAX_ZIP_CODE 10 
#define MAX_NAME_LENGTH 50
#DEFINE MAX_VALUE_LENGTH 100

typedef struct 
{
  char zipcode[6]; //Zipcode stored
  char name[MAX_NAME_LENGTH]; //name of data
  char value[MAX_VALUE_LENGTH]; //temp
  char clean_enviornment[MAX_VALUE_LENGTH]; // clean enviorment
  char water_contamination[MAX_VALUE_LENGTH]; // water contamination
  char air_quality[MAS_VALUE_LENGTH]; //store air quality
  time_t last_updated; //timestamp
} HDATA;

//array fixed size 
HDATA health_data[MAX_ZIP_CODE];
int health_data_count = 0;

//data fetch
void data_fetch (const chat *zipcode, char *name, char *value, *clean_enviornment, char *clean_water_contamination, char *air_quality)
    FILE *file = fopen("health_data.csv", "r");// Open the file 
    if (!file) {
        // If the file cannot be opened, set error messages.
        strcpy(name, "Error");
        strcpy(value, "Unable to open data file");
        return;
    }

  char line[256];  // Buffer for reading each line from the CSV file.
    while (fgets(line, sizeof(line), file))
      {
        char file_zipcode[6];
        double heat_index, temperature;
        char env[MAX_VALUE_LENGTH], water[MAX_VALUE_LENGTH], air[MAX_VALUE_LENGTH];

        // Parse the line, assuming CSV format.
        if (sscanf(line, "%5[^,],%lf,%lf,%49[^,],%49[^,],%49[^\n]", 
                   file_zipcode, &heat_index, &temperature, env, water, air) == 6)
          {
            // Check if the current line's ZIP code matches the requested ZIP code.
            if (strcmp(file_zipcode, zipcode) == 0) 
              {
                // Format and store the health data information in `name` and `value`.
                snprintf(name, MAX_NAME_LENGTH, "Health Data (%s)", zipcode);
                snprintf(value, MAX_VALUE_LENGTH, "Heat Index: %.1f°F, Temperature: %.1f°F", 
                         heat_index, temperature);
                // Store additional data (environment, water, air) in their respective fields.
                strncpy(clean_environment, env, MAX_VALUE_LENGTH - 1);
                clean_environment[MAX_VALUE_LENGTH - 1] = '\0';
                strncpy(clean_water_contamination, water, MAX_VALUE_LENGTH - 1);
                clean_water_contamination[MAX_VALUE_LENGTH - 1] = '\0';
                strncpy(air_quality, air, MAX_VALUE_LENGTH - 1);
                air_quality[MAX_VALUE_LENGTH - 1] = '\0';
                fclose(file);  // Close the file after finding the data.
                return;
               }
            }
          }

    // If no ZIP code is found in the file, set default error messages.
    strcpy(name, "Error");
    strcpy(value, "No data available for this ZIP code");
    strcpy(clean_environment, "N/A");
    strcpy(clean_water_contamination, "N/A");
    strcpy(air_quality, "N/A");

    fclose(file);  // Close the file.
}
// Function to create or update health data using the fixed-size array.
void create_or_update_health_data(const char *zipcode, const char *name, const char *value, 
                                   const char *clean_environment, const char *clean_water_contamination, 
                                   const char *air_quality) {
    // Check if the health data already exists in the fixed array.
    for (int i = 0; i < health_data_count; i++) 
    {
        if (strcmp(health_data[i].zipcode, zipcode) == 0) 
        {
            // Update the existing health data.
            strncpy(health_data[i].value, value, MAX_VALUE_LENGTH - 1);
            health_data[i].value[MAX_VALUE_LENGTH - 1] = '\0';
            strncpy(health_data[i].clean_environment, clean_environment, MAX_VALUE_LENGTH - 1);
            strncpy(health_data[i].clean_water_contamination, clean_water_contamination, MAX_VALUE_LENGTH - 1);
            strncpy(health_data[i].air_quality, air_quality, MAX_VALUE_LENGTH - 1);
            health_data[i].last_updated = time(NULL);  // Update the timestamp.
            return;  // Exit the function after updating.
        }
    }
 // If no health data was found for the given ZIP code and we still have space, create a new one.
    if (health_data_count < MAX_ZIPCODES) {
        strncpy(health_data[health_data_count].zipcode, zipcode, 5);
        health_data[health_data_count].zipcode[5] = '\0';  // Null terminate the string.
        strncpy(health_data[health_data_count].name, name, MAX_NAME_LENGTH - 1);
        health_data[health_data_count].name[MAX_NAME_LENGTH - 1] = '\0';  // Null terminate the string.
        strncpy(health_data[health_data_count].value, value, MAX_VALUE_LENGTH - 1);
        health_data[health_data_count].value[MAX_VALUE_LENGTH - 1] = '\0';  // Null terminate the string.
        strncpy(health_data[health_data_count].clean_environment, clean_environment, MAX_VALUE_LENGTH - 1);
        strncpy(health_data[health_data_count].clean_water_contamination, clean_water_contamination, MAX_VALUE_LENGTH - 1);
        strncpy(health_data[health_data_count].air_quality, air_quality, MAX_VALUE_LENGTH - 1);
        health_data[health_data_count].last_updated = time(NULL);  // Set the current time as the last updated time.
        health_data_count++;  // Increment the count of health data entries.
    } 
    else 
    {
        printf("Maximum number of health data entries reached.\n");
    }
}

// Function to update health data based on user input for a ZIP code.
void update_health_data() 
{
    char zipcode[6];  // Buffer to store the ZIP code input by the user.
    printf("Enter ZIP code to update: ");
    scanf("%5s", zipcode);  // Read up to 5 characters for the ZIP code.

    // Buffers to store fetched data.
    char name[MAX_NAME_LENGTH];
    char value[MAX_VALUE_LENGTH];
    char clean_environment[MAX_VALUE_LENGTH];
    char clean_water_contamination[MAX_VALUE_LENGTH];
    char air_quality[MAX_VALUE_LENGTH];

    // Fetch health data for the entered ZIP code.
    read_health_data(zipcode, name, value, clean_environment, clean_water_contamination, air_quality);

    // Create a new health data entry or update an existing one with the fetched data.
    create_or_update_health_data(zipcode, name, value, clean_environment, clean_water_contamination, air_quality);
}
// Function to display all health data entries.
void display_health_data()
{
    printf("\n--- Health Index by ZIP Code ---\n");
    for (int i = 0; i < health_data_count; i++)
  {
        // Format the last updated time into a readable string.
        char time_str[26];
        ctime_r(&health_data[i].last_updated, time_str);
        time_str[24] = '\0';  // Remove newline character.

        // Print out all details of the health data entry.
        printf("ZIP Code: %s\n", health_data[i].zipcode);
        printf("Name: %s\n", health_data[i].name);
        printf("Value: %s\n", health_data[i].value);
        printf("Clean Environment: %s\n", health_data[i].clean_environment);
        printf("Clean Water Contamination: %s\n", health_data[i].clean_water_contamination);
        printf("Air Quality: %s\n", health_data[i].air_quality);
        printf("Last updated: %s\n\n", time_str);
    }
    printf("-----------------------------\n");
}
int main() 
{
    // Main loop to handle user interactions.
    while (1) 
    {
        display_health_data();  // Show the current state of the health data.

        // Display user options.
        printf("\nOptions:\n");
        printf("1. Add/Update health data by ZIP code\n");
        printf("2. Exit\n");
        printf("Enter your choice: ");

        int choice;
        scanf("%d", &choice);  // Read user's choice.

        // Handle user input.
        switch (choice) 
          {
            case 1:
                update_health_data();  // Update or add new health data.
            break;
            case 2:
                printf("Exiting...\n");
                return 0; 
            default:
                printf("Invalid choice. Please try again.\n");  // invalid input.
          }
        }
      return 0;  
  }
